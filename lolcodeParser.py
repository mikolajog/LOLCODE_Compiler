# Generated from lolcode.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3.")
        buf.write("\u0114\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\3\2\3\2\3\2\5\2@\n\2\3\3\6\3C\n\3\r\3\16\3D\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4P\n\4\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\5\6_\n\6\3\7\3\7\3")
        buf.write("\7\3\7\3\7\5\7f\n\7\3\b\3\b\7\bj\n\b\f\b\16\bm\13\b\3")
        buf.write("\b\5\bp\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\5\t}\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\5\n\u008a\n\n\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\7\f\u0096\n\f\f\f\16\f\u0099\13\f\5\f\u009b\n\f")
        buf.write("\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\5\16\u00b6\n\16\3\17\3\17\3\17\3\17\3\17\3")
        buf.write("\20\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3\22")
        buf.write("\3\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\26")
        buf.write("\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\30\3\30\3\30\3\30")
        buf.write("\3\30\3\31\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\32\3\33")
        buf.write("\3\33\3\33\3\33\7\33\u00f7\n\33\f\33\16\33\u00fa\13\33")
        buf.write("\3\33\3\33\3\34\3\34\3\34\3\34\7\34\u0102\n\34\f\34\16")
        buf.write("\34\u0105\13\34\3\34\3\34\3\35\3\35\3\35\3\36\3\36\6\36")
        buf.write("\u010e\n\36\r\36\16\36\u010f\3\36\3\36\3\36\2\2\37\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64")
        buf.write("\668:\2\2\2\u011d\2<\3\2\2\2\4B\3\2\2\2\6O\3\2\2\2\bQ")
        buf.write("\3\2\2\2\n^\3\2\2\2\fe\3\2\2\2\16g\3\2\2\2\20|\3\2\2\2")
        buf.write("\22\u0089\3\2\2\2\24\u008b\3\2\2\2\26\u008e\3\2\2\2\30")
        buf.write("\u009f\3\2\2\2\32\u00b5\3\2\2\2\34\u00b7\3\2\2\2\36\u00bc")
        buf.write("\3\2\2\2 \u00c1\3\2\2\2\"\u00c6\3\2\2\2$\u00cb\3\2\2\2")
        buf.write("&\u00d0\3\2\2\2(\u00d5\3\2\2\2*\u00da\3\2\2\2,\u00df\3")
        buf.write("\2\2\2.\u00e4\3\2\2\2\60\u00e9\3\2\2\2\62\u00ee\3\2\2")
        buf.write("\2\64\u00f2\3\2\2\2\66\u00fd\3\2\2\28\u0108\3\2\2\2:\u010b")
        buf.write("\3\2\2\2<=\7\3\2\2=?\5\4\3\2>@\7\4\2\2?>\3\2\2\2?@\3\2")
        buf.write("\2\2@\3\3\2\2\2AC\5\6\4\2BA\3\2\2\2CD\3\2\2\2DB\3\2\2")
        buf.write("\2DE\3\2\2\2E\5\3\2\2\2FP\5\b\5\2GP\5\n\6\2HP\5\f\7\2")
        buf.write("IP\5\16\b\2JP\5\20\t\2KP\5\24\13\2LP\5\26\f\2MP\5\30\r")
        buf.write("\2NP\5\32\16\2OF\3\2\2\2OG\3\2\2\2OH\3\2\2\2OI\3\2\2\2")
        buf.write("OJ\3\2\2\2OK\3\2\2\2OL\3\2\2\2OM\3\2\2\2ON\3\2\2\2P\7")
        buf.write("\3\2\2\2QR\7\5\2\2RS\7+\2\2ST\7\6\2\2TU\5\32\16\2UV\5")
        buf.write("\4\3\2VW\7\7\2\2WX\7+\2\2X\t\3\2\2\2YZ\7\b\2\2Z_\7+\2")
        buf.write("\2[\\\7\b\2\2\\]\7+\2\2]_\7\t\2\2^Y\3\2\2\2^[\3\2\2\2")
        buf.write("_\13\3\2\2\2`a\7\n\2\2af\7-\2\2bc\7\13\2\2cd\7-\2\2df")
        buf.write("\7\f\2\2e`\3\2\2\2eb\3\2\2\2f\r\3\2\2\2gk\7\r\2\2hj\5")
        buf.write("\32\16\2ih\3\2\2\2jm\3\2\2\2ki\3\2\2\2kl\3\2\2\2lo\3\2")
        buf.write("\2\2mk\3\2\2\2np\7\16\2\2on\3\2\2\2op\3\2\2\2p\17\3\2")
        buf.write("\2\2qr\7\17\2\2rs\7\20\2\2st\5\4\3\2tu\7\21\2\2u}\3\2")
        buf.write("\2\2vw\7\17\2\2wx\7\20\2\2xy\5\4\3\2yz\5\22\n\2z{\7\21")
        buf.write("\2\2{}\3\2\2\2|q\3\2\2\2|v\3\2\2\2}\21\3\2\2\2~\177\7")
        buf.write("\22\2\2\177\u0080\5\32\16\2\u0080\u0081\5\4\3\2\u0081")
        buf.write("\u0082\5\22\n\2\u0082\u008a\3\2\2\2\u0083\u0084\7\23\2")
        buf.write("\2\u0084\u008a\5\4\3\2\u0085\u0086\7\22\2\2\u0086\u0087")
        buf.write("\5\32\16\2\u0087\u0088\5\4\3\2\u0088\u008a\3\2\2\2\u0089")
        buf.write("~\3\2\2\2\u0089\u0083\3\2\2\2\u0089\u0085\3\2\2\2\u008a")
        buf.write("\23\3\2\2\2\u008b\u008c\7\24\2\2\u008c\u008d\7+\2\2\u008d")
        buf.write("\25\3\2\2\2\u008e\u008f\7\25\2\2\u008f\u009a\7+\2\2\u0090")
        buf.write("\u0091\7\26\2\2\u0091\u0092\7+\2\2\u0092\u0097\3\2\2\2")
        buf.write("\u0093\u0094\7\27\2\2\u0094\u0096\7+\2\2\u0095\u0093\3")
        buf.write("\2\2\2\u0096\u0099\3\2\2\2\u0097\u0095\3\2\2\2\u0097\u0098")
        buf.write("\3\2\2\2\u0098\u009b\3\2\2\2\u0099\u0097\3\2\2\2\u009a")
        buf.write("\u0090\3\2\2\2\u009a\u009b\3\2\2\2\u009b\u009c\3\2\2\2")
        buf.write("\u009c\u009d\5\4\3\2\u009d\u009e\7\30\2\2\u009e\27\3\2")
        buf.write("\2\2\u009f\u00a0\7+\2\2\u00a0\u00a1\7\31\2\2\u00a1\u00a2")
        buf.write("\5\32\16\2\u00a2\31\3\2\2\2\u00a3\u00b6\5\34\17\2\u00a4")
        buf.write("\u00b6\5 \21\2\u00a5\u00b6\5\36\20\2\u00a6\u00b6\5$\23")
        buf.write("\2\u00a7\u00b6\5&\24\2\u00a8\u00b6\5(\25\2\u00a9\u00b6")
        buf.write("\5*\26\2\u00aa\u00b6\5,\27\2\u00ab\u00b6\5.\30\2\u00ac")
        buf.write("\u00b6\5\60\31\2\u00ad\u00b6\5\62\32\2\u00ae\u00b6\5\"")
        buf.write("\22\2\u00af\u00b6\5\64\33\2\u00b0\u00b6\5\66\34\2\u00b1")
        buf.write("\u00b6\58\35\2\u00b2\u00b6\5:\36\2\u00b3\u00b6\7+\2\2")
        buf.write("\u00b4\u00b6\7,\2\2\u00b5\u00a3\3\2\2\2\u00b5\u00a4\3")
        buf.write("\2\2\2\u00b5\u00a5\3\2\2\2\u00b5\u00a6\3\2\2\2\u00b5\u00a7")
        buf.write("\3\2\2\2\u00b5\u00a8\3\2\2\2\u00b5\u00a9\3\2\2\2\u00b5")
        buf.write("\u00aa\3\2\2\2\u00b5\u00ab\3\2\2\2\u00b5\u00ac\3\2\2\2")
        buf.write("\u00b5\u00ad\3\2\2\2\u00b5\u00ae\3\2\2\2\u00b5\u00af\3")
        buf.write("\2\2\2\u00b5\u00b0\3\2\2\2\u00b5\u00b1\3\2\2\2\u00b5\u00b2")
        buf.write("\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b5\u00b4\3\2\2\2\u00b6")
        buf.write("\33\3\2\2\2\u00b7\u00b8\7\32\2\2\u00b8\u00b9\5\32\16\2")
        buf.write("\u00b9\u00ba\7\33\2\2\u00ba\u00bb\5\32\16\2\u00bb\35\3")
        buf.write("\2\2\2\u00bc\u00bd\7\34\2\2\u00bd\u00be\5\32\16\2\u00be")
        buf.write("\u00bf\7\33\2\2\u00bf\u00c0\5\32\16\2\u00c0\37\3\2\2\2")
        buf.write("\u00c1\u00c2\7\35\2\2\u00c2\u00c3\5\32\16\2\u00c3\u00c4")
        buf.write("\7\33\2\2\u00c4\u00c5\5\32\16\2\u00c5!\3\2\2\2\u00c6\u00c7")
        buf.write("\7\36\2\2\u00c7\u00c8\5\32\16\2\u00c8\u00c9\7\33\2\2\u00c9")
        buf.write("\u00ca\5\32\16\2\u00ca#\3\2\2\2\u00cb\u00cc\7\37\2\2\u00cc")
        buf.write("\u00cd\5\32\16\2\u00cd\u00ce\7\33\2\2\u00ce\u00cf\5\32")
        buf.write("\16\2\u00cf%\3\2\2\2\u00d0\u00d1\7 \2\2\u00d1\u00d2\5")
        buf.write("\32\16\2\u00d2\u00d3\7\33\2\2\u00d3\u00d4\5\32\16\2\u00d4")
        buf.write("\'\3\2\2\2\u00d5\u00d6\7!\2\2\u00d6\u00d7\5\32\16\2\u00d7")
        buf.write("\u00d8\7\33\2\2\u00d8\u00d9\5\32\16\2\u00d9)\3\2\2\2\u00da")
        buf.write("\u00db\7\"\2\2\u00db\u00dc\5\32\16\2\u00dc\u00dd\7\33")
        buf.write("\2\2\u00dd\u00de\5\32\16\2\u00de+\3\2\2\2\u00df\u00e0")
        buf.write("\7#\2\2\u00e0\u00e1\5\32\16\2\u00e1\u00e2\7\33\2\2\u00e2")
        buf.write("\u00e3\5\32\16\2\u00e3-\3\2\2\2\u00e4\u00e5\7$\2\2\u00e5")
        buf.write("\u00e6\5\32\16\2\u00e6\u00e7\7\33\2\2\u00e7\u00e8\5\32")
        buf.write("\16\2\u00e8/\3\2\2\2\u00e9\u00ea\7%\2\2\u00ea\u00eb\5")
        buf.write("\32\16\2\u00eb\u00ec\7\33\2\2\u00ec\u00ed\5\32\16\2\u00ed")
        buf.write("\61\3\2\2\2\u00ee\u00ef\7&\2\2\u00ef\u00f0\5\32\16\2\u00f0")
        buf.write("\u00f1\7\'\2\2\u00f1\63\3\2\2\2\u00f2\u00f3\7(\2\2\u00f3")
        buf.write("\u00f8\5\32\16\2\u00f4\u00f5\7\33\2\2\u00f5\u00f7\5\32")
        buf.write("\16\2\u00f6\u00f4\3\2\2\2\u00f7\u00fa\3\2\2\2\u00f8\u00f6")
        buf.write("\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9\u00fb\3\2\2\2\u00fa")
        buf.write("\u00f8\3\2\2\2\u00fb\u00fc\7\16\2\2\u00fc\65\3\2\2\2\u00fd")
        buf.write("\u00fe\7)\2\2\u00fe\u0103\5\32\16\2\u00ff\u0100\7\33\2")
        buf.write("\2\u0100\u0102\5\32\16\2\u0101\u00ff\3\2\2\2\u0102\u0105")
        buf.write("\3\2\2\2\u0103\u0101\3\2\2\2\u0103\u0104\3\2\2\2\u0104")
        buf.write("\u0106\3\2\2\2\u0105\u0103\3\2\2\2\u0106\u0107\7\16\2")
        buf.write("\2\u0107\67\3\2\2\2\u0108\u0109\7*\2\2\u0109\u010a\5\32")
        buf.write("\16\2\u010a9\3\2\2\2\u010b\u010d\7+\2\2\u010c\u010e\5")
        buf.write("\32\16\2\u010d\u010c\3\2\2\2\u010e\u010f\3\2\2\2\u010f")
        buf.write("\u010d\3\2\2\2\u010f\u0110\3\2\2\2\u0110\u0111\3\2\2\2")
        buf.write("\u0111\u0112\7\16\2\2\u0112;\3\2\2\2\21?DO^eko|\u0089")
        buf.write("\u0097\u009a\u00b5\u00f8\u0103\u010f")
        return buf.getvalue()


class lolcodeParser ( Parser ):

    grammarFileName = "lolcode.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'HAI'", "'KTHXBYE'", "'IM IN YR'", "'WILE'", 
                     "'IM OUTTA YR'", "'I HAS A'", "'ITZ'", "'BTW'", "'OBTW'", 
                     "'TLDR'", "'VISIBLE'", "'MKAY?'", "'O RLY?'", "'YA RLY'", 
                     "'OIC'", "'MEBBE'", "'NO WAI'", "'GIMMEH'", "'HOW DUZ I'", 
                     "'YR'", "'AN YR'", "'IF U SAY SO'", "'R'", "'BOTH SAEM'", 
                     "'AN'", "'DIFFRINT'", "'BOTH OF'", "'EITHER OF'", "'BIGGR OF'", 
                     "'SMALLR OF'", "'SUM OF'", "'DIFF OF'", "'PRODUKT OF'", 
                     "'QUOSHUNT OF'", "'MOD OF'", "'MAEK'", "'A'", "'ALL OF'", 
                     "'ANY OF'", "'NOT'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "LABEL", "ATOM", "STRING", "WS" ]

    RULE_program = 0
    RULE_code_block = 1
    RULE_statement = 2
    RULE_loop = 3
    RULE_declaration = 4
    RULE_comment = 5
    RULE_print_block = 6
    RULE_if_block = 7
    RULE_else_if_block = 8
    RULE_input_block = 9
    RULE_func_decl = 10
    RULE_assignment = 11
    RULE_expression = 12
    RULE_equals = 13
    RULE_not_equals = 14
    RULE_both = 15
    RULE_either = 16
    RULE_greater = 17
    RULE_less = 18
    RULE_add = 19
    RULE_sub = 20
    RULE_mul = 21
    RULE_div = 22
    RULE_mod = 23
    RULE_cast = 24
    RULE_r_all = 25
    RULE_r_any = 26
    RULE_r_not = 27
    RULE_func = 28

    ruleNames =  [ "program", "code_block", "statement", "loop", "declaration", 
                   "comment", "print_block", "if_block", "else_if_block", 
                   "input_block", "func_decl", "assignment", "expression", 
                   "equals", "not_equals", "both", "either", "greater", 
                   "less", "add", "sub", "mul", "div", "mod", "cast", "r_all", 
                   "r_any", "r_not", "func" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    LABEL=41
    ATOM=42
    STRING=43
    WS=44

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = lolcodeParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(lolcodeParser.T__0)
            self.state = 59
            self.code_block()
            self.state = 61
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__1:
                self.state = 60
                self.match(lolcodeParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Code_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.StatementContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.StatementContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_code_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCode_block" ):
                listener.enterCode_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCode_block" ):
                listener.exitCode_block(self)




    def code_block(self):

        localctx = lolcodeParser.Code_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_code_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 63
                self.statement()
                self.state = 66 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lolcodeParser.T__2) | (1 << lolcodeParser.T__5) | (1 << lolcodeParser.T__7) | (1 << lolcodeParser.T__8) | (1 << lolcodeParser.T__10) | (1 << lolcodeParser.T__12) | (1 << lolcodeParser.T__17) | (1 << lolcodeParser.T__18) | (1 << lolcodeParser.T__23) | (1 << lolcodeParser.T__25) | (1 << lolcodeParser.T__26) | (1 << lolcodeParser.T__27) | (1 << lolcodeParser.T__28) | (1 << lolcodeParser.T__29) | (1 << lolcodeParser.T__30) | (1 << lolcodeParser.T__31) | (1 << lolcodeParser.T__32) | (1 << lolcodeParser.T__33) | (1 << lolcodeParser.T__34) | (1 << lolcodeParser.T__35) | (1 << lolcodeParser.T__37) | (1 << lolcodeParser.T__38) | (1 << lolcodeParser.T__39) | (1 << lolcodeParser.LABEL) | (1 << lolcodeParser.ATOM))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loop(self):
            return self.getTypedRuleContext(lolcodeParser.LoopContext,0)


        def declaration(self):
            return self.getTypedRuleContext(lolcodeParser.DeclarationContext,0)


        def comment(self):
            return self.getTypedRuleContext(lolcodeParser.CommentContext,0)


        def print_block(self):
            return self.getTypedRuleContext(lolcodeParser.Print_blockContext,0)


        def if_block(self):
            return self.getTypedRuleContext(lolcodeParser.If_blockContext,0)


        def input_block(self):
            return self.getTypedRuleContext(lolcodeParser.Input_blockContext,0)


        def func_decl(self):
            return self.getTypedRuleContext(lolcodeParser.Func_declContext,0)


        def assignment(self):
            return self.getTypedRuleContext(lolcodeParser.AssignmentContext,0)


        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = lolcodeParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.state = 77
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.loop()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 69
                self.declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 70
                self.comment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 71
                self.print_block()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 72
                self.if_block()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 73
                self.input_block()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 74
                self.func_decl()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 75
                self.assignment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 76
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LoopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.LABEL)
            else:
                return self.getToken(lolcodeParser.LABEL, i)

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop" ):
                listener.enterLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop" ):
                listener.exitLoop(self)




    def loop(self):

        localctx = lolcodeParser.LoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(lolcodeParser.T__2)
            self.state = 80
            self.match(lolcodeParser.LABEL)
            self.state = 81
            self.match(lolcodeParser.T__3)
            self.state = 82
            self.expression()
            self.state = 83
            self.code_block()
            self.state = 84
            self.match(lolcodeParser.T__4)
            self.state = 85
            self.match(lolcodeParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = lolcodeParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_declaration)
        try:
            self.state = 92
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 87
                self.match(lolcodeParser.T__5)
                self.state = 88
                self.match(lolcodeParser.LABEL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 89
                self.match(lolcodeParser.T__5)
                self.state = 90
                self.match(lolcodeParser.LABEL)
                self.state = 91
                self.match(lolcodeParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(lolcodeParser.STRING, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)




    def comment(self):

        localctx = lolcodeParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_comment)
        try:
            self.state = 99
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lolcodeParser.T__7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 94
                self.match(lolcodeParser.T__7)
                self.state = 95
                self.match(lolcodeParser.STRING)
                pass
            elif token in [lolcodeParser.T__8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 96
                self.match(lolcodeParser.T__8)
                self.state = 97
                self.match(lolcodeParser.STRING)
                self.state = 98
                self.match(lolcodeParser.T__9)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Print_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_print_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrint_block" ):
                listener.enterPrint_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrint_block" ):
                listener.exitPrint_block(self)




    def print_block(self):

        localctx = lolcodeParser.Print_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_print_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(lolcodeParser.T__10)
            self.state = 105
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 102
                    self.expression() 
                self.state = 107
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__11:
                self.state = 108
                self.match(lolcodeParser.T__11)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class If_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def else_if_block(self):
            return self.getTypedRuleContext(lolcodeParser.Else_if_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_if_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_block" ):
                listener.enterIf_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_block" ):
                listener.exitIf_block(self)




    def if_block(self):

        localctx = lolcodeParser.If_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_if_block)
        try:
            self.state = 122
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 111
                self.match(lolcodeParser.T__12)
                self.state = 112
                self.match(lolcodeParser.T__13)
                self.state = 113
                self.code_block()
                self.state = 114
                self.match(lolcodeParser.T__14)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.match(lolcodeParser.T__12)
                self.state = 117
                self.match(lolcodeParser.T__13)
                self.state = 118
                self.code_block()
                self.state = 119
                self.else_if_block()
                self.state = 120
                self.match(lolcodeParser.T__14)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Else_if_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def else_if_block(self):
            return self.getTypedRuleContext(lolcodeParser.Else_if_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_else_if_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElse_if_block" ):
                listener.enterElse_if_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElse_if_block" ):
                listener.exitElse_if_block(self)




    def else_if_block(self):

        localctx = lolcodeParser.Else_if_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_else_if_block)
        try:
            self.state = 135
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 124
                self.match(lolcodeParser.T__15)
                self.state = 125
                self.expression()
                self.state = 126
                self.code_block()
                self.state = 127
                self.else_if_block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 129
                self.match(lolcodeParser.T__16)
                self.state = 130
                self.code_block()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 131
                self.match(lolcodeParser.T__15)
                self.state = 132
                self.expression()
                self.state = 133
                self.code_block()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Input_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_input_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInput_block" ):
                listener.enterInput_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInput_block" ):
                listener.exitInput_block(self)




    def input_block(self):

        localctx = lolcodeParser.Input_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_input_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(lolcodeParser.T__17)
            self.state = 138
            self.match(lolcodeParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self, i:int=None):
            if i is None:
                return self.getTokens(lolcodeParser.LABEL)
            else:
                return self.getToken(lolcodeParser.LABEL, i)

        def code_block(self):
            return self.getTypedRuleContext(lolcodeParser.Code_blockContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_func_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_decl" ):
                listener.enterFunc_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_decl" ):
                listener.exitFunc_decl(self)




    def func_decl(self):

        localctx = lolcodeParser.Func_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_func_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(lolcodeParser.T__18)
            self.state = 141
            self.match(lolcodeParser.LABEL)
            self.state = 152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lolcodeParser.T__19:
                self.state = 142
                self.match(lolcodeParser.T__19)
                self.state = 143
                self.match(lolcodeParser.LABEL)
                self.state = 149
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==lolcodeParser.T__20:
                    self.state = 145
                    self.match(lolcodeParser.T__20)
                    self.state = 146
                    self.match(lolcodeParser.LABEL)
                    self.state = 151
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 154
            self.code_block()
            self.state = 155
            self.match(lolcodeParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)




    def assignment(self):

        localctx = lolcodeParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.match(lolcodeParser.LABEL)
            self.state = 158
            self.match(lolcodeParser.T__22)
            self.state = 159
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equals(self):
            return self.getTypedRuleContext(lolcodeParser.EqualsContext,0)


        def both(self):
            return self.getTypedRuleContext(lolcodeParser.BothContext,0)


        def not_equals(self):
            return self.getTypedRuleContext(lolcodeParser.Not_equalsContext,0)


        def greater(self):
            return self.getTypedRuleContext(lolcodeParser.GreaterContext,0)


        def less(self):
            return self.getTypedRuleContext(lolcodeParser.LessContext,0)


        def add(self):
            return self.getTypedRuleContext(lolcodeParser.AddContext,0)


        def sub(self):
            return self.getTypedRuleContext(lolcodeParser.SubContext,0)


        def mul(self):
            return self.getTypedRuleContext(lolcodeParser.MulContext,0)


        def div(self):
            return self.getTypedRuleContext(lolcodeParser.DivContext,0)


        def mod(self):
            return self.getTypedRuleContext(lolcodeParser.ModContext,0)


        def cast(self):
            return self.getTypedRuleContext(lolcodeParser.CastContext,0)


        def either(self):
            return self.getTypedRuleContext(lolcodeParser.EitherContext,0)


        def r_all(self):
            return self.getTypedRuleContext(lolcodeParser.R_allContext,0)


        def r_any(self):
            return self.getTypedRuleContext(lolcodeParser.R_anyContext,0)


        def r_not(self):
            return self.getTypedRuleContext(lolcodeParser.R_notContext,0)


        def func(self):
            return self.getTypedRuleContext(lolcodeParser.FuncContext,0)


        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def ATOM(self):
            return self.getToken(lolcodeParser.ATOM, 0)

        def getRuleIndex(self):
            return lolcodeParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = lolcodeParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_expression)
        try:
            self.state = 179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 161
                self.equals()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.both()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 163
                self.not_equals()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 164
                self.greater()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 165
                self.less()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 166
                self.add()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 167
                self.sub()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 168
                self.mul()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 169
                self.div()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 170
                self.mod()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 171
                self.cast()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 172
                self.either()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 173
                self.r_all()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 174
                self.r_any()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 175
                self.r_not()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 176
                self.func()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 177
                self.match(lolcodeParser.LABEL)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 178
                self.match(lolcodeParser.ATOM)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EqualsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_equals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquals" ):
                listener.enterEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquals" ):
                listener.exitEquals(self)




    def equals(self):

        localctx = lolcodeParser.EqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_equals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(lolcodeParser.T__23)
            self.state = 182
            self.expression()
            self.state = 183
            self.match(lolcodeParser.T__24)
            self.state = 184
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Not_equalsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_not_equals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNot_equals" ):
                listener.enterNot_equals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNot_equals" ):
                listener.exitNot_equals(self)




    def not_equals(self):

        localctx = lolcodeParser.Not_equalsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_not_equals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(lolcodeParser.T__25)
            self.state = 187
            self.expression()
            self.state = 188
            self.match(lolcodeParser.T__24)
            self.state = 189
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BothContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_both

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoth" ):
                listener.enterBoth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoth" ):
                listener.exitBoth(self)




    def both(self):

        localctx = lolcodeParser.BothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_both)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.match(lolcodeParser.T__26)
            self.state = 192
            self.expression()
            self.state = 193
            self.match(lolcodeParser.T__24)
            self.state = 194
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EitherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_either

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEither" ):
                listener.enterEither(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEither" ):
                listener.exitEither(self)




    def either(self):

        localctx = lolcodeParser.EitherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_either)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(lolcodeParser.T__27)
            self.state = 197
            self.expression()
            self.state = 198
            self.match(lolcodeParser.T__24)
            self.state = 199
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GreaterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_greater

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGreater" ):
                listener.enterGreater(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGreater" ):
                listener.exitGreater(self)




    def greater(self):

        localctx = lolcodeParser.GreaterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_greater)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(lolcodeParser.T__28)
            self.state = 202
            self.expression()
            self.state = 203
            self.match(lolcodeParser.T__24)
            self.state = 204
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LessContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_less

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLess" ):
                listener.enterLess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLess" ):
                listener.exitLess(self)




    def less(self):

        localctx = lolcodeParser.LessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_less)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(lolcodeParser.T__29)
            self.state = 207
            self.expression()
            self.state = 208
            self.match(lolcodeParser.T__24)
            self.state = 209
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)




    def add(self):

        localctx = lolcodeParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_add)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(lolcodeParser.T__30)
            self.state = 212
            self.expression()
            self.state = 213
            self.match(lolcodeParser.T__24)
            self.state = 214
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)




    def sub(self):

        localctx = lolcodeParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_sub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(lolcodeParser.T__31)
            self.state = 217
            self.expression()
            self.state = 218
            self.match(lolcodeParser.T__24)
            self.state = 219
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MulContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_mul

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul" ):
                listener.enterMul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul" ):
                listener.exitMul(self)




    def mul(self):

        localctx = lolcodeParser.MulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_mul)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.match(lolcodeParser.T__32)
            self.state = 222
            self.expression()
            self.state = 223
            self.match(lolcodeParser.T__24)
            self.state = 224
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DivContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_div

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiv" ):
                listener.enterDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiv" ):
                listener.exitDiv(self)




    def div(self):

        localctx = lolcodeParser.DivContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_div)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(lolcodeParser.T__33)
            self.state = 227
            self.expression()
            self.state = 228
            self.match(lolcodeParser.T__24)
            self.state = 229
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_mod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMod" ):
                listener.enterMod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMod" ):
                listener.exitMod(self)




    def mod(self):

        localctx = lolcodeParser.ModContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_mod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(lolcodeParser.T__34)
            self.state = 232
            self.expression()
            self.state = 233
            self.match(lolcodeParser.T__24)
            self.state = 234
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)




    def cast(self):

        localctx = lolcodeParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(lolcodeParser.T__35)
            self.state = 237
            self.expression()
            self.state = 238
            self.match(lolcodeParser.T__36)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class R_allContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_all

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_all" ):
                listener.enterR_all(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_all" ):
                listener.exitR_all(self)




    def r_all(self):

        localctx = lolcodeParser.R_allContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_r_all)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.match(lolcodeParser.T__37)
            self.state = 241
            self.expression()
            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__24:
                self.state = 242
                self.match(lolcodeParser.T__24)
                self.state = 243
                self.expression()
                self.state = 248
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 249
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class R_anyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_any

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_any" ):
                listener.enterR_any(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_any" ):
                listener.exitR_any(self)




    def r_any(self):

        localctx = lolcodeParser.R_anyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_r_any)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.match(lolcodeParser.T__38)
            self.state = 252
            self.expression()
            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lolcodeParser.T__24:
                self.state = 253
                self.match(lolcodeParser.T__24)
                self.state = 254
                self.expression()
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 260
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class R_notContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(lolcodeParser.ExpressionContext,0)


        def getRuleIndex(self):
            return lolcodeParser.RULE_r_not

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_not" ):
                listener.enterR_not(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_not" ):
                listener.exitR_not(self)




    def r_not(self):

        localctx = lolcodeParser.R_notContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_r_not)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(lolcodeParser.T__39)
            self.state = 263
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(lolcodeParser.LABEL, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lolcodeParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(lolcodeParser.ExpressionContext,i)


        def getRuleIndex(self):
            return lolcodeParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)




    def func(self):

        localctx = lolcodeParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(lolcodeParser.LABEL)
            self.state = 267 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 266
                self.expression()
                self.state = 269 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lolcodeParser.T__23) | (1 << lolcodeParser.T__25) | (1 << lolcodeParser.T__26) | (1 << lolcodeParser.T__27) | (1 << lolcodeParser.T__28) | (1 << lolcodeParser.T__29) | (1 << lolcodeParser.T__30) | (1 << lolcodeParser.T__31) | (1 << lolcodeParser.T__32) | (1 << lolcodeParser.T__33) | (1 << lolcodeParser.T__34) | (1 << lolcodeParser.T__35) | (1 << lolcodeParser.T__37) | (1 << lolcodeParser.T__38) | (1 << lolcodeParser.T__39) | (1 << lolcodeParser.LABEL) | (1 << lolcodeParser.ATOM))) != 0)):
                    break

            self.state = 271
            self.match(lolcodeParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





